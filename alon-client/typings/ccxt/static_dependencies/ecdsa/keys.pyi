"""
This type stub file was generated by pyright.
"""

class BadSignatureError(Exception):
    ...


class BadDigestError(Exception):
    ...


class VerifyingKey:
    def __init__(self, _error__please_use_generate=...) -> None:
        ...
    
    @classmethod
    def from_public_point(klass, point, curve=..., hashfunc=...): # -> Self:
        ...
    
    @classmethod
    def from_string(klass, string, curve=..., hashfunc=..., validate_point=...): # -> Self:
        ...
    
    @classmethod
    def from_pem(klass, string): # -> Self:
        ...
    
    @classmethod
    def from_der(klass, string): # -> Self:
        ...
    
    @classmethod
    def from_public_key_recovery(klass, signature, data, curve, hashfunc=..., sigdecode=...): # -> list[Self]:
        ...
    
    @classmethod
    def from_public_key_recovery_with_digest(klass, signature, digest, curve, hashfunc=..., sigdecode=...): # -> list[Self]:
        ...
    
    def to_string(self): # -> bytes:
        ...
    
    def to_pem(self): # -> bytes:
        ...
    
    def to_der(self): # -> bytes:
        ...
    
    def verify(self, signature, data, hashfunc=..., sigdecode=...): # -> Literal[True]:
        ...
    
    def verify_digest(self, signature, digest, sigdecode=...): # -> Literal[True]:
        ...
    


class SigningKey:
    def __init__(self, _error__please_use_generate=...) -> None:
        ...
    
    @classmethod
    def generate(klass, curve=..., entropy=..., hashfunc=...): # -> Self:
        ...
    
    @classmethod
    def from_secret_exponent(klass, secexp, curve=..., hashfunc=...): # -> Self:
        ...
    
    @classmethod
    def from_string(klass, string, curve=..., hashfunc=...): # -> Self:
        ...
    
    @classmethod
    def from_pem(klass, string, hashfunc=...): # -> Self:
        ...
    
    @classmethod
    def from_der(klass, string, hashfunc=...): # -> Self:
        ...
    
    def to_string(self): # -> bytes:
        ...
    
    def to_pem(self): # -> bytes:
        ...
    
    def to_der(self): # -> bytes:
        ...
    
    def get_verifying_key(self):
        ...
    
    def sign_deterministic(self, data, hashfunc=..., sigencode=..., extra_entropy=...):
        ...
    
    def sign_digest_deterministic(self, digest, hashfunc=..., sigencode=..., extra_entropy=...):
        """
        Calculates 'k' from data itself, removing the need for strong
        random generator and producing deterministic (reproducible) signatures.
        See RFC 6979 for more details.
        """
        ...
    
    def sign(self, data, entropy=..., hashfunc=..., sigencode=..., k=...):
        """
        hashfunc= should behave like hashlib.sha1 . The output length of the
        hash (in bytes) must not be longer than the length of the curve order
        (rounded up to the nearest byte), so using SHA256 with nist256p is
        ok, but SHA256 with nist192p is not. (In the 2**-96ish unlikely event
        of a hash output larger than the curve order, the hash will
        effectively be wrapped mod n).

        Use hashfunc=hashlib.sha1 to match openssl's -ecdsa-with-SHA1 mode,
        or hashfunc=hashlib.sha256 for openssl-1.0.0's -ecdsa-with-SHA256.
        """
        ...
    
    def sign_digest(self, digest, entropy=..., sigencode=..., k=...):
        ...
    
    def sign_number(self, number, entropy=..., k=...): # -> tuple[Any, Any, Any]:
        ...
    


