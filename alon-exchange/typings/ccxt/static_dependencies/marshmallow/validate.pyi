"""
This type stub file was generated by pyright.
"""

import typing
from abc import ABC, abstractmethod
from . import types

"""Validation classes for various types of data."""
_T = typing.TypeVar("_T")
class Validator(ABC):
    """Abstract base class for validators.

    .. note::
        This class does not provide any validation behavior. It is only used to
        add a useful `__repr__` implementation for validators.
    """
    error: str | None = ...
    def __repr__(self) -> str:
        ...
    
    @abstractmethod
    def __call__(self, value: typing.Any) -> typing.Any:
        ...
    


class And(Validator):
    """Compose multiple validators and combine their error messages.

    Example: ::

        from . import validate, ValidationError


        def is_even(value):
            if value % 2 != 0:
                raise ValidationError("Not an even value.")


        validator = validate.And(validate.Range(min=0), is_even)
        validator(-1)
        # ValidationError: ['Must be greater than or equal to 0.', 'Not an even value.']

    :param validators: Validators to combine.
    :param error: Error message to use when a validator returns ``False``.
    """
    default_error_message = ...
    def __init__(self, *validators: types.Validator, error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: typing.Any) -> typing.Any:
        ...
    


class URL(Validator):
    """Validate a URL.

    :param relative: Whether to allow relative URLs.
    :param absolute: Whether to allow absolute URLs.
    :param error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}`.
    :param schemes: Valid schemes. By default, ``http``, ``https``,
        ``ftp``, and ``ftps`` are allowed.
    :param require_tld: Whether to reject non-FQDN hostnames.
    """
    class RegexMemoizer:
        def __init__(self) -> None:
            ...
        
        def __call__(self, relative: bool, absolute: bool, require_tld: bool) -> typing.Pattern:
            ...
        
    
    
    _regex = ...
    default_message = ...
    default_schemes = ...
    def __init__(self, *, relative: bool = ..., absolute: bool = ..., schemes: types.StrSequenceOrSet | None = ..., require_tld: bool = ..., error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: str) -> str:
        ...
    


class Email(Validator):
    """Validate an email address.

    :param error: Error message to raise in case of a validation error. Can be
        interpolated with `{input}`.
    """
    USER_REGEX = ...
    DOMAIN_REGEX = ...
    DOMAIN_WHITELIST = ...
    default_message = ...
    def __init__(self, *, error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: str) -> str:
        ...
    


class Range(Validator):
    """Validator which succeeds if the value passed to it is within the specified
    range. If ``min`` is not specified, or is specified as `None`,
    no lower bound exists. If ``max`` is not specified, or is specified as `None`,
    no upper bound exists. The inclusivity of the bounds (if they exist) is configurable.
    If ``min_inclusive`` is not specified, or is specified as `True`, then
    the ``min`` bound is included in the range. If ``max_inclusive`` is not specified,
    or is specified as `True`, then the ``max`` bound is included in the range.

    :param min: The minimum value (lower bound). If not provided, minimum
        value will not be checked.
    :param max: The maximum value (upper bound). If not provided, maximum
        value will not be checked.
    :param min_inclusive: Whether the `min` bound is included in the range.
    :param max_inclusive: Whether the `max` bound is included in the range.
    :param error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}`, `{min}` and `{max}`.
    """
    message_min = ...
    message_max = ...
    message_all = ...
    message_gte = ...
    message_gt = ...
    message_lte = ...
    message_lt = ...
    def __init__(self, min=..., max=..., *, min_inclusive: bool = ..., max_inclusive: bool = ..., error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: _T) -> _T:
        ...
    


class Length(Validator):
    """Validator which succeeds if the value passed to it has a
    length between a minimum and maximum. Uses len(), so it
    can work for strings, lists, or anything with length.

    :param min: The minimum length. If not provided, minimum length
        will not be checked.
    :param max: The maximum length. If not provided, maximum length
        will not be checked.
    :param equal: The exact length. If provided, maximum and minimum
        length will not be checked.
    :param error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}`, `{min}` and `{max}`.
    """
    message_min = ...
    message_max = ...
    message_all = ...
    message_equal = ...
    def __init__(self, min: int | None = ..., max: int | None = ..., *, equal: int | None = ..., error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: typing.Sized) -> typing.Sized:
        ...
    


class Equal(Validator):
    """Validator which succeeds if the ``value`` passed to it is
    equal to ``comparable``.

    :param comparable: The object to compare to.
    :param error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}` and `{other}`.
    """
    default_message = ...
    def __init__(self, comparable, *, error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: _T) -> _T:
        ...
    


class Regexp(Validator):
    """Validator which succeeds if the ``value`` matches ``regex``.

    .. note::

        Uses `re.match`, which searches for a match at the beginning of a string.

    :param regex: The regular expression string to use. Can also be a compiled
        regular expression pattern.
    :param flags: The regexp flags to use, for example re.IGNORECASE. Ignored
        if ``regex`` is not a string.
    :param error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}` and `{regex}`.
    """
    default_message = ...
    def __init__(self, regex: str | bytes | typing.Pattern, flags: int = ..., *, error: str | None = ...) -> None:
        ...
    
    @typing.overload
    def __call__(self, value: str) -> str:
        ...
    
    @typing.overload
    def __call__(self, value: bytes) -> bytes:
        ...
    
    def __call__(self, value): # -> Any:
        ...
    


class Predicate(Validator):
    """Call the specified ``method`` of the ``value`` object. The
    validator succeeds if the invoked method returns an object that
    evaluates to True in a Boolean context. Any additional keyword
    argument will be passed to the method.

    :param method: The name of the method to invoke.
    :param error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}` and `{method}`.
    :param kwargs: Additional keyword arguments to pass to the method.
    """
    default_message = ...
    def __init__(self, method: str, *, error: str | None = ..., **kwargs) -> None:
        ...
    
    def __call__(self, value: typing.Any) -> typing.Any:
        ...
    


class NoneOf(Validator):
    """Validator which fails if ``value`` is a member of ``iterable``.

    :param iterable: A sequence of invalid values.
    :param error: Error message to raise in case of a validation error. Can be
        interpolated using `{input}` and `{values}`.
    """
    default_message = ...
    def __init__(self, iterable: typing.Iterable, *, error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: typing.Any) -> typing.Any:
        ...
    


class OneOf(Validator):
    """Validator which succeeds if ``value`` is a member of ``choices``.

    :param choices: A sequence of valid values.
    :param labels: Optional sequence of labels to pair with the choices.
    :param error: Error message to raise in case of a validation error. Can be
        interpolated with `{input}`, `{choices}` and `{labels}`.
    """
    default_message = ...
    def __init__(self, choices: typing.Iterable, labels: typing.Iterable[str] | None = ..., *, error: str | None = ...) -> None:
        ...
    
    def __call__(self, value: typing.Any) -> typing.Any:
        ...
    
    def options(self, valuegetter: str | typing.Callable[[typing.Any], typing.Any] = ...) -> typing.Iterable[tuple[typing.Any, str]]:
        """Return a generator over the (value, label) pairs, where value
        is a string associated with each choice. This convenience method
        is useful to populate, for instance, a form select field.

        :param valuegetter: Can be a callable or a string. In the former case, it must
            be a one-argument callable which returns the value of a
            choice. In the latter case, the string specifies the name
            of an attribute of the choice objects. Defaults to `str()`
            or `str()`.
        """
        ...
    


class ContainsOnly(OneOf):
    """Validator which succeeds if ``value`` is a sequence and each element
    in the sequence is also in the sequence passed as ``choices``. Empty input
    is considered valid.

    :param iterable choices: Same as :class:`OneOf`.
    :param iterable labels: Same as :class:`OneOf`.
    :param str error: Same as :class:`OneOf`.

    .. versionchanged:: 3.0.0b2
        Duplicate values are considered valid.
    .. versionchanged:: 3.0.0b2
        Empty input is considered valid. Use `validate.Length(min=1) <marshmallow.validate.Length>`
        to validate against empty inputs.
    """
    default_message = ...
    def __call__(self, value: typing.Sequence[_T]) -> typing.Sequence[_T]:
        ...
    


class ContainsNoneOf(NoneOf):
    """Validator which fails if ``value`` is a sequence and any element
    in the sequence is a member of the sequence passed as ``iterable``. Empty input
    is considered valid.

    :param iterable iterable: Same as :class:`NoneOf`.
    :param str error: Same as :class:`NoneOf`.

    .. versionadded:: 3.6.0
    """
    default_message = ...
    def __call__(self, value: typing.Sequence[_T]) -> typing.Sequence[_T]:
        ...
    


