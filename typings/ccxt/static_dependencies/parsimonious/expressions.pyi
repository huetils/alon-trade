"""
This type stub file was generated by pyright.
"""

from .utils import StrAndRepr

"""Subexpressions that make up a parsed grammar

These do the parsing.

"""
MARKER = ...
def is_callable(value): # -> bool:
    ...

def expression(callable, rule_name, grammar): # -> AdHocExpression:
    """Turn a plain callable into an Expression.

    The callable can be of this simple form::

        def foo(text, pos):
            '''If this custom expression matches starting at text[pos], return
            the index where it stops matching. Otherwise, return None.'''
            if the expression matched:
                return end_pos

    If there child nodes to return, return a tuple::

        return end_pos, children

    If the expression doesn't match at the given ``pos`` at all... ::

        return None

    If your callable needs to make sub-calls to other rules in the grammar or
    do error reporting, it can take this form, gaining additional arguments::

        def foo(text, pos, cache, error, grammar):
            # Call out to other rules:
            node = grammar['another_rule'].match_core(text, pos, cache, error)
            ...
            # Return values as above.

    The return value of the callable, if an int or a tuple, will be
    automatically transmuted into a :class:`~.Node`. If it returns
    a Node-like class directly, it will be passed through unchanged.

    :arg rule_name: The rule name to attach to the resulting
        :class:`~.Expression`
    :arg grammar: The :class:`~.Grammar` this expression will be a
        part of, to make delegating to other rules possible

    """
    class AdHocExpression(Expression):
        ...
    
    

class Expression(StrAndRepr):
    """A thing that can be matched against a piece of text"""
    __slots__ = ...
    def __init__(self, name=...) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def parse(self, text, pos=...):
        """Return a parse tree of ``text``.

        Raise ``ParseError`` if the expression wasn't satisfied. Raise
        ``IncompleteParseError`` if the expression was satisfied but didn't
        consume the full string.

        """
        ...
    
    def match(self, text, pos=...):
        """Return the parse tree matching this expression at the given
        position, not necessarily extending all the way to the end of ``text``.

        Raise ``ParseError`` if there is no match there.

        :arg pos: The index at which to start matching

        """
        ...
    
    def match_core(self, text, pos, cache, error):
        """Internal guts of ``match()``

        This is appropriate to call only from custom rules or Expression
        subclasses.

        :arg cache: The packrat cache::

            {(oid, pos): Node tree matched by object `oid` at index `pos` ...}

        :arg error: A ParseError instance with ``text`` already filled in but
            otherwise blank. We update the error reporting info on this object
            as we go. (Sticking references on an existing instance is faster
            than allocating a new one for each expression that fails.) We
            return None rather than raising and catching ParseErrors because
            catching is slow.

        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def as_rule(self): # -> str:
        """Return the left- and right-hand sides of a rule that represents me.

        Return unicode. If I have no ``name``, omit the left-hand side.

        """
        ...
    


class Literal(Expression):
    """A string literal

    Use these if you can; they're the fastest.

    """
    __slots__ = ...
    def __init__(self, literal, name=...) -> None:
        ...
    


class TokenMatcher(Literal):
    """An expression matching a single token of a given type

    This is for use only with TokenGrammars.

    """
    ...


class Regex(Expression):
    """An expression that matches what a regex does.

    Use these as much as you can and jam as much into each one as you can;
    they're fast.

    """
    __slots__ = ...
    def __init__(self, pattern, name=..., ignore_case=..., locale=..., multiline=..., dot_all=..., unicode=..., verbose=..., ascii=...) -> None:
        ...
    


class Compound(Expression):
    """An abstract expression which contains other expressions"""
    __slots__ = ...
    def __init__(self, *members, **kwargs) -> None:
        """``members`` is a sequence of expressions."""
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


class Sequence(Compound):
    """A series of expressions that must match contiguous, ordered pieces of
    the text

    In other words, it's a concatenation operator: each piece has to match, one
    after another.

    """
    ...


class OneOf(Compound):
    """A series of expressions, one of which must match

    Expressions are tested in order from first to last. The first to succeed
    wins.

    """
    ...


class Lookahead(Compound):
    """An expression which consumes nothing, even if its contained expression
    succeeds"""
    ...


class Not(Compound):
    """An expression that succeeds only if the expression within it doesn't

    In any case, it never consumes any characters; it's a negative lookahead.

    """
    ...


class Optional(Compound):
    """An expression that succeeds whether or not the contained one does

    If the contained expression succeeds, it goes ahead and consumes what it
    consumes. Otherwise, it consumes nothing.

    """
    ...


class ZeroOrMore(Compound):
    """An expression wrapper like the * quantifier in regexes."""
    ...


class OneOrMore(Compound):
    """An expression wrapper like the + quantifier in regexes.

    You can also pass in an alternate minimum to make this behave like "2 or
    more", "3 or more", etc.

    """
    __slots__ = ...
    def __init__(self, member, name=..., min=...) -> None:
        ...
    


