"""
This type stub file was generated by pyright.
"""

import abc
import io
from typing import Any
from ..utils import to_tuple
from .base import BaseCoder, parse_tuple_type_str, parse_type_str

class ContextFramesBytesIO(io.BytesIO):
    """
    A byte stream which can track a series of contextual frames in a stack. This
    data structure is necessary to perform nested decodings using the
    :py:class:``HeadTailDecoder`` since offsets present in head sections are
    relative only to a particular encoded object.  These offsets can only be
    used to locate a position in a decoding stream if they are paired with a
    contextual offset that establishes the position of the object in which they
    are found.

    For example, consider the encoding of a value for the following type::

        type: (int,(int,int[]))
        value: (1,(2,[3,3]))

    There are two tuples in this type: one inner and one outer.  The inner tuple
    type contains a dynamic type ``int[]`` and, therefore, is itself dynamic.
    This means that its value encoding will be placed in the tail section of the
    outer tuple's encoding.  Furthermore, the inner tuple's encoding will,
    itself, contain a tail section with the encoding for ``[3,3]``.  All
    together, the encoded value of ``(1,(2,[3,3]))`` would look like this (the
    data values are normally 32 bytes wide but have been truncated to remove the
    redundant zeros at the beginnings of their encodings)::

                       offset data
        --------------------------
             ^              0 0x01
             |             32 0x40 <-- Offset of object A in global frame (64)
        -----|--------------------
        Global frame ^     64 0x02 <-- Beginning of object A (64 w/offset 0 = 64)
             |       |     96 0x40 <-- Offset of object B in frame of object A (64)
        -----|-Object A's frame---
             |       |    128 0x02 <-- Beginning of object B (64 w/offset 64 = 128)
             |       |    160 0x03
             v       v    192 0x03
        --------------------------

    Note that the offset of object B is encoded as 64 which only specifies the
    beginning of its encoded value relative to the beginning of object A's
    encoding.  Globally, object B is located at offset 128.  In order to make
    sense out of object B's offset, it needs to be positioned in the context of
    its enclosing object's frame (object A).
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def seek_in_frame(self, pos, *args, **kwargs): # -> None:
        """
        Seeks relative to the total offset of the current contextual frames.
        """
        ...
    
    def push_frame(self, offset): # -> None:
        """
        Pushes a new contextual frame onto the stack with the given offset and a
        return position at the current cursor position then seeks to the new
        total offset.
        """
        ...
    
    def pop_frame(self): # -> None:
        """
        Pops the current contextual frame off of the stack and returns the
        cursor to the frame's return position.
        """
        ...
    


class BaseDecoder(BaseCoder, metaclass=abc.ABCMeta):
    """
    Base class for all decoder classes.  Subclass this if you want to define a
    custom decoder class.  Subclasses must also implement
    :any:`BaseCoder.from_type_str`.
    """
    @abc.abstractmethod
    def decode(self, stream: ContextFramesBytesIO) -> Any:
        """
        Decodes the given stream of bytes into a python value.  Should raise
        :any:`exceptions.DecodingError` if a python value cannot be decoded
        from the given byte stream.
        """
        ...
    
    def __call__(self, stream: ContextFramesBytesIO) -> Any:
        ...
    


class HeadTailDecoder(BaseDecoder):
    is_dynamic = ...
    tail_decoder = ...
    def validate(self): # -> None:
        ...
    
    def decode(self, stream):
        ...
    


class TupleDecoder(BaseDecoder):
    decoders = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def validate(self): # -> None:
        ...
    
    @to_tuple
    def decode(self, stream): # -> Generator[Any, Any, None]:
        ...
    
    @parse_tuple_type_str
    def from_type_str(cls, abi_type, registry):
        ...
    


class SingleDecoder(BaseDecoder):
    decoder_fn = ...
    def validate(self): # -> None:
        ...
    
    def validate_padding_bytes(self, value, padding_bytes):
        ...
    
    def decode(self, stream):
        ...
    
    def read_data_from_stream(self, stream):
        ...
    
    def split_data_and_padding(self, raw_data): # -> tuple[Any, Literal[b""]]:
        ...
    


class BaseArrayDecoder(BaseDecoder):
    item_decoder = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def validate(self): # -> None:
        ...
    
    @parse_type_str(with_arrlist=True)
    def from_type_str(cls, abi_type, registry): # -> SizedArrayDecoder | DynamicArrayDecoder:
        ...
    


class SizedArrayDecoder(BaseArrayDecoder):
    array_size = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    @to_tuple
    def decode(self, stream): # -> Generator[Any, Any, None]:
        ...
    


class DynamicArrayDecoder(BaseArrayDecoder):
    is_dynamic = ...
    @to_tuple
    def decode(self, stream): # -> Generator[Any, Any, None]:
        ...
    


class FixedByteSizeDecoder(SingleDecoder):
    decoder_fn = ...
    value_bit_size = ...
    data_byte_size = ...
    is_big_endian = ...
    def validate(self): # -> None:
        ...
    
    def read_data_from_stream(self, stream):
        ...
    
    def split_data_and_padding(self, raw_data): # -> tuple[Any, Any]:
        ...
    
    def validate_padding_bytes(self, value, padding_bytes): # -> None:
        ...
    


class Fixed32ByteSizeDecoder(FixedByteSizeDecoder):
    data_byte_size = ...


class BooleanDecoder(Fixed32ByteSizeDecoder):
    value_bit_size = ...
    is_big_endian = ...
    @staticmethod
    def decoder_fn(data): # -> bool:
        ...
    
    @parse_type_str("bool")
    def from_type_str(cls, abi_type, registry):
        ...
    


class AddressDecoder(Fixed32ByteSizeDecoder):
    value_bit_size = ...
    is_big_endian = ...
    decoder_fn = ...
    @parse_type_str("address")
    def from_type_str(cls, abi_type, registry):
        ...
    


class UnsignedIntegerDecoder(Fixed32ByteSizeDecoder):
    decoder_fn = ...
    is_big_endian = ...
    @parse_type_str("uint")
    def from_type_str(cls, abi_type, registry):
        ...
    


decode_uint_256 = ...
class SignedIntegerDecoder(Fixed32ByteSizeDecoder):
    is_big_endian = ...
    def decoder_fn(self, data): # -> int:
        ...
    
    def validate_padding_bytes(self, value, padding_bytes): # -> None:
        ...
    
    @parse_type_str("int")
    def from_type_str(cls, abi_type, registry):
        ...
    


class BytesDecoder(Fixed32ByteSizeDecoder):
    is_big_endian = ...
    @staticmethod
    def decoder_fn(data):
        ...
    
    @parse_type_str("bytes")
    def from_type_str(cls, abi_type, registry):
        ...
    


class BaseFixedDecoder(Fixed32ByteSizeDecoder):
    frac_places = ...
    is_big_endian = ...
    def validate(self): # -> None:
        ...
    


class UnsignedFixedDecoder(BaseFixedDecoder):
    def decoder_fn(self, data):
        ...
    
    @parse_type_str("ufixed")
    def from_type_str(cls, abi_type, registry):
        ...
    


class SignedFixedDecoder(BaseFixedDecoder):
    def decoder_fn(self, data):
        ...
    
    def validate_padding_bytes(self, value, padding_bytes): # -> None:
        ...
    
    @parse_type_str("fixed")
    def from_type_str(cls, abi_type, registry):
        ...
    


class ByteStringDecoder(SingleDecoder):
    is_dynamic = ...
    @staticmethod
    def decoder_fn(data):
        ...
    
    @staticmethod
    def read_data_from_stream(stream):
        ...
    
    def validate_padding_bytes(self, value, padding_bytes): # -> None:
        ...
    
    @parse_type_str("bytes")
    def from_type_str(cls, abi_type, registry):
        ...
    


class StringDecoder(ByteStringDecoder):
    @parse_type_str("string")
    def from_type_str(cls, abi_type, registry):
        ...
    
    @staticmethod
    def decoder_fn(data):
        ...
    


