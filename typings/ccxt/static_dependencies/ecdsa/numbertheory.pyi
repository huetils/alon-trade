"""
This type stub file was generated by pyright.
"""

class Error(Exception):
    """Base class for exceptions in this module."""
    ...


class SquareRootError(Error):
    ...


class NegativeExponentError(Error):
    ...


def modular_exp(base, exponent, modulus):
    "Raise base to exponent, reducing by modulus"
    ...

def polynomial_reduce_mod(poly, polymod, p):
    """Reduce poly by polymod, integer arithmetic modulo p.

  Polynomials are represented as lists of coefficients
  of increasing powers of x."""
    ...

def polynomial_multiply_mod(m1, m2, polymod, p): # -> list[int]:
    """Polynomial multiplication modulo a polynomial over ints mod p.

  Polynomials are represented as lists of coefficients
  of increasing powers of x."""
    ...

def polynomial_exp_mod(base, exponent, polymod, p): # -> list[int]:
    """Polynomial exponentiation modulo a polynomial over ints mod p.

  Polynomials are represented as lists of coefficients
  of increasing powers of x."""
    ...

def jacobi(a, n): # -> int:
    """Jacobi symbol"""
    ...

def square_root_mod_prime(a, p): # -> int:
    """Modular square root of a, mod p, p prime."""
    ...

def inverse_mod(a, m): # -> Literal[0, 1]:
    """Inverse of a mod m."""
    ...

def gcd2(a, b):
    """Greatest common divisor using Euclid's algorithm."""
    ...

def gcd(*a):
    """Greatest common divisor.

  Usage: gcd([ 2, 4, 6 ])
  or:    gcd(2, 4, 6)
  """
    ...

def lcm2(a, b):
    """Least common multiple of two integers."""
    ...

def lcm(*a):
    """Least common multiple.

  Usage: lcm([ 3, 4, 5 ])
  or:    lcm(3, 4, 5)
  """
    ...

def factorization(n): # -> list[Any]:
    """Decompose n into a list of (prime,exponent) pairs."""
    ...

def phi(n): # -> Literal[1]:
    """Return the Euler totient function of n."""
    ...

def carmichael(n): # -> Literal[1]:
    """Return Carmichael function of n.

  Carmichael(n) is the smallest integer x such that
  m**x = 1 mod n for all m relatively prime to n.
  """
    ...

def carmichael_of_factorized(f_list): # -> Literal[1]:
    """Return the Carmichael function of a number that is
  represented as a list of (prime,exponent) pairs.
  """
    ...

def carmichael_of_ppower(pp):
    """Carmichael function of the given power of the given prime.
  """
    ...

def order_mod(x, m): # -> int:
    """Return the order of x in the multiplicative group mod m.
  """
    ...

def largest_factor_relatively_prime(a, b):
    """Return the largest factor of a relatively prime to b.
  """
    ...

def kinda_order_mod(x, m): # -> int:
    """Return the order of x in the multiplicative group mod m',
  where m' is the largest factor of m relatively prime to x.
  """
    ...

def is_prime(n): # -> bool:
    """Return True if x is prime, False otherwise.

  We use the Miller-Rabin test, as given in Menezes et al. p. 138.
  This test is not exact: there are composite values n for which
  it returns True.

  In testing the odd numbers from 10000001 to 19999999,
  about 66 composites got past the first test,
  5 got past the second test, and none got past the third.
  Since factors of 2, 3, 5, 7, and 11 were detected during
  preliminary screening, the number of numbers tested by
  Miller-Rabin was (19999999 - 10000001)*(2/3)*(4/5)*(6/7)
  = 4.57 million.
  """
    ...

def next_prime(starting_value): # -> Literal[2]:
    "Return the smallest prime larger than the starting value."
    ...

smallprimes = ...
miller_rabin_test_count = ...
