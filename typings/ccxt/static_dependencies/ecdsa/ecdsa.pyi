"""
This type stub file was generated by pyright.
"""

"""
Implementation of Elliptic-Curve Digital Signatures.

Classes and methods for elliptic-curve signatures:
private keys, public keys, signatures,
NIST prime-modulus curves with modulus lengths of
192, 224, 256, 384, and 521 bits.

Example:

  # (In real-life applications, you would probably want to
  # protect against defects in SystemRandom.)
  from random import SystemRandom
  randrange = SystemRandom().randrange

  # Generate a public/private key pair using the NIST Curve P-192:

  g = generator_192
  n = g.order()
  secret = randrange( 1, n )
  pubkey = Public_key( g, g * secret )
  privkey = Private_key( pubkey, secret )

  # Signing a hash value:

  hash = randrange( 1, n )
  signature = privkey.sign( hash, randrange( 1, n ) )

  # Verifying a signature for a hash value:

  if pubkey.verifies( hash, signature ):
    print_("Demo verification succeeded.")
  else:
    print_("*** Demo verification failed.")

  # Verification fails if the hash value is modified:

  if pubkey.verifies( hash-1, signature ):
    print_("**** Demo verification failed to reject tampered hash.")
  else:
    print_("Demo verification correctly rejected tampered hash.")

Version of 2009.05.16.

Revision history:
      2005.12.31 - Initial version.
      2008.11.25 - Substantial revisions introducing new classes.
      2009.05.16 - Warn against using random.randrange in real applications.
      2009.05.17 - Use random.SystemRandom by default.

Written in 2005 by Peter Pearson and placed in the public domain.
"""

class RSZeroError(RuntimeError): ...

class Signature:
    """ECDSA signature."""
    def __init__(self, r, s, recovery_param) -> None: ...
    def recover_public_keys(self, hash, generator):  # -> list[Public_key]:
        """Returns two public keys for which the signature is valid
        hash is signed hash
        generator is the used generator of the signature
        """
        ...

class Public_key:
    """Public key for ECDSA."""
    def __init__(self, generator, point) -> None:
        """generator is the Point that generates the group,
        point is the Point that defines the public key.
        """
        ...

    def verifies(self, hash, signature):  # -> Literal[False]:
        """Verify that signature is a valid signature of hash.
        Return True if the signature is valid.
        """
        ...

class Private_key:
    """Private key for ECDSA."""
    def __init__(self, public_key, secret_multiplier) -> None:
        """public_key is of class Public_key;
        secret_multiplier is a large integer.
        """
        ...

    def sign(self, hash, random_k):  # -> Signature:
        """Return a signature for the provided hash, using the provided
        random nonce.  It is absolutely vital that random_k be an unpredictable
        number in the range [1, self.public_key.point.order()-1].  If
        an attacker can guess random_k, he can compute our private key from a
        single signature.  Also, if an attacker knows a few high-order
        bits (or a few low-order bits) of random_k, he can compute our private
        key from many signatures.  The generation of nonces with adequate
        cryptographic strength is very difficult and far beyond the scope
        of this comment.

        May raise RuntimeError, in which case retrying with a new
        random value k is in order.
        """
        ...

def int_to_string(x):  # -> bytes:
    """Convert integer x into a string of bytes, as per X9.62."""
    ...

def string_to_int(s):  # -> int:
    """Convert a string of bytes into an integer, as per X9.62."""
    ...

def digest_integer(m):  # -> int:
    """Convert an integer into a string of bytes, compute
    its SHA-1 hash, and convert the result to an integer."""
    ...

def point_is_valid(generator, x, y):  # -> bool:
    """Is (x,y) a valid public key based on the specified generator?"""
    ...

_p = ...
_r = ...
_b = ...
_Gx = ...
_Gy = ...
curve_192 = ...
generator_192 = ...
_p = ...
_r = ...
_b = ...
_Gx = ...
_Gy = ...
curve_224 = ...
generator_224 = ...
_p = ...
_r = ...
_b = ...
_Gx = ...
_Gy = ...
curve_256 = ...
generator_256 = ...
_p = ...
_r = ...
_b = ...
_Gx = ...
_Gy = ...
curve_384 = ...
generator_384 = ...
_p = ...
_r = ...
_b = ...
_Gx = ...
_Gy = ...
curve_521 = ...
generator_521 = ...
_a = ...
_b = ...
_p = ...
_Gx = ...
_Gy = ...
_r = ...
curve_secp256k1 = ...
generator_secp256k1 = ...
