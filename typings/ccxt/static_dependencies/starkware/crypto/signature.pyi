"""
This type stub file was generated by pyright.
"""

from typing import Optional, Tuple

from .math_utils import ECPoint

FIELD_PRIME = ...
FIELD_GEN = ...
ALPHA = ...
BETA = ...
EC_ORDER = ...
CONSTANT_POINTS = ...
N_ELEMENT_BITS_ECDSA = ...
N_ELEMENT_BITS_HASH = ...
SHIFT_POINT = ...
MINUS_SHIFT_POINT = ...
EC_GEN = ...
ECSignature = Tuple[int, int]

class InvalidPublicKeyError(Exception):
    def __init__(self) -> None: ...

def get_y_coordinate(stark_key_x_coordinate: int) -> int:
    """
    Given the x coordinate of a stark_key, returns a possible y coordinate such that together the
    point (x,y) is on the curve.
    Note that the real y coordinate is either y or -y.
    If x is invalid stark_key it throws an error.
    """
    ...

def get_random_private_key() -> int: ...
def private_key_to_ec_point_on_stark_curve(priv_key: int) -> ECPoint: ...
def private_to_stark_key(priv_key: int) -> int: ...
def inv_mod_curve_size(x: int) -> int: ...
def generate_k_rfc6979(
    msg_hash: int, priv_key: int, seed: Optional[int] = ...
) -> int: ...
def sign(msg_hash: int, priv_key: int, seed: Optional[int] = ...) -> ECSignature: ...
def mimic_ec_mult_air(m: int, point: ECPoint, shift_point: ECPoint) -> ECPoint:
    """
    Computes m * point + shift_point using the same steps like the AIR and throws an exception if
    and only if the AIR errors.
    """
    ...

def is_point_on_curve(x: int, y: int) -> bool: ...
def is_valid_stark_private_key(private_key: int) -> bool:
    """
    Returns whether the given input is a valid STARK private key.
    """
    ...

def grind_key(key_seed: int, key_value_limit: int) -> int:
    """
    Given a cryptographically-secure seed and a limit, deterministically generates a pseudorandom
    key in the range [0, limit).
    This is a reference implementation, and cryptographic security is not guaranteed (for example,
    it may be vulnerable to side-channel attacks); this function is not recommended for use with key
    generation on mainnet.
    """
    ...

def pedersen_hash(*elements: int) -> int: ...
def pedersen_hash_as_point(*elements: int) -> ECPoint:
    """
    Similar to pedersen_hash but also returns the y coordinate of the resulting EC point.
    This function is used for testing.
    """
    ...
